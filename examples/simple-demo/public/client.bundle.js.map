{
  "version": 3,
  "sources": ["../../../packages/client/src/bridge.ts", "../../../packages/client/src/index.ts", "../src/client.ts"],
  "sourcesContent": ["import { TunnelRequest, TunnelResponse, HttpReqStart, HttpRes, TunnelMessage, HttpResChunk } from \"@http-over-webrtc/shared\";\n\ninterface PendingTransfer {\n    chunks: Uint8Array[];\n    mime: string;\n    totalSize: number;\n}\n\nexport class WebRtcHttpBridge {\n    private dc: RTCDataChannel;\n    private transfers: Map<string, PendingTransfer> = new Map();\n\n    constructor(dc: RTCDataChannel) {\n        this.dc = dc;\n        this.setupDataChannel();\n        this.setupServiceWorker();\n    }\n\n    private setupDataChannel() {\n        this.dc.addEventListener(\"message\", (event) => {\n            try {\n                const msg = JSON.parse(event.data) as TunnelMessage;\n                this.handleMessage(msg);\n            } catch (e) {\n                console.error(\"[Bridge] Failed to parse DC message\", e);\n            }\n        });\n    }\n\n    private handleMessage(msg: TunnelMessage) {\n        // console.log(\"[Bridge] Rx Msg:\", msg.type, msg.id);\n        if (msg.type === \"HTTP_RES\") {\n            const isBinary = !msg.mime.startsWith(\"text/\") && msg.mime !== \"application/json\";\n\n            let body = msg.data;\n            if (isBinary && typeof msg.data === 'string') {\n                body = this.base64ToArrayBuffer(msg.data);\n            }\n\n            this.sendToSw({\n                type: \"TUNNEL_RESPONSE\",\n                requestId: msg.id,\n                status: msg.status,\n                statusText: \"OK\",\n                headers: { \"Content-Type\": msg.mime },\n                body: body,\n                isBinary: isBinary\n            });\n        }\n        else if (msg.type === \"HTTP_RES_METADATA\") {\n            this.transfers.set(msg.id, {\n                chunks: [],\n                mime: msg.mime,\n                totalSize: 0\n            });\n        }\n        else if (msg.type === \"HTTP_RES_CHUNK\") {\n            const transfer = this.transfers.get(msg.id);\n            if (transfer) {\n                const chunkBuffer = this.base64ToArrayBuffer(msg.data); // Decode immediately\n                // Convert ArrayBuffer to Uint8Array for storage\n                transfer.chunks.push(new Uint8Array(chunkBuffer));\n                transfer.totalSize += chunkBuffer.byteLength;\n            } else {\n                console.warn(\"[Bridge] Received chunk for unknown transfer\", msg.id);\n            }\n        }\n        else if (msg.type === \"HTTP_RES_END\") {\n            const transfer = this.transfers.get(msg.id);\n            if (transfer) {\n                this.transfers.delete(msg.id);\n                // Reassemble binary\n                const combinedBuffer = new Uint8Array(transfer.totalSize);\n                let offset = 0;\n                for (const chunk of transfer.chunks) {\n                    combinedBuffer.set(chunk, offset);\n                    offset += chunk.length;\n                }\n\n                this.sendToSw({\n                    type: \"TUNNEL_RESPONSE\",\n                    requestId: msg.id,\n                    status: 200,\n                    statusText: \"OK\",\n                    headers: { \"Content-Type\": transfer.mime },\n                    body: combinedBuffer.buffer,\n                    isBinary: true\n                });\n            }\n        }\n    }\n\n    private base64ToArrayBuffer(base64: string): ArrayBuffer {\n        const binaryString = atob(base64);\n        const len = binaryString.length;\n        const bytes = new Uint8Array(len);\n        for (let i = 0; i < len; i++) {\n            bytes[i] = binaryString.charCodeAt(i);\n        }\n        return bytes.buffer;\n    }\n\n    private setupServiceWorker() {\n        if (!navigator.serviceWorker) return;\n\n        navigator.serviceWorker.addEventListener(\"message\", (event) => {\n            const msg = event.data as TunnelRequest;\n            if (msg && msg.type === \"TUNNEL_REQUEST\") {\n                // console.log(\"[Bridge] Received request from SW\", msg.url);\n\n                const hostReq: HttpReqStart = {\n                    type: \"HTTP_REQ_START\",\n                    id: msg.requestId,\n                    method: msg.method,\n                    path: new URL(msg.url).pathname,\n                    body: msg.body\n                };\n\n                if (this.dc.readyState === \"open\") {\n                    this.dc.send(JSON.stringify(hostReq));\n                } else {\n                    console.warn(\"[Bridge] DC not open\");\n                    this.sendToSw({\n                        type: \"TUNNEL_RESPONSE\",\n                        requestId: msg.requestId,\n                        status: 503,\n                        statusText: \"Service Unavailable\",\n                        headers: {},\n                        body: \"WebRTC DataChannel not connected\",\n                        isBinary: false\n                    });\n                }\n            }\n        });\n    }\n\n    private sendToSw(msg: TunnelResponse) {\n        if (navigator.serviceWorker.controller) {\n            const transferList = (msg.isBinary && msg.body instanceof ArrayBuffer) ? [msg.body] : [];\n            navigator.serviceWorker.controller.postMessage(msg, transferList);\n        }\n    }\n}\n", "export * from \"./bridge\";\n// export * from \"./sw\"; // SW is usually an entry point, not exported directly\n", "import { WebRtcHttpBridge } from \"@http-over-webrtc/client\";\n\nconst statusEl = document.getElementById('status')!;\nconst ws = new WebSocket('ws://localhost:8080');\nconst pc = new RTCPeerConnection({\n    iceServers: [{ urls: 'stun:stun.l.google.com:19302' }]\n});\n\n// Create Data Channel\nconst dc = pc.createDataChannel(\"http-proxy\");\nconst bridge = new WebRtcHttpBridge(dc);\n\ndc.onopen = () => {\n    console.log(\"DataChannel Open!\");\n    statusEl.innerHTML = \"Connected! Loading /p2p/index.html...\";\n\n    // Register Service Worker\n    navigator.serviceWorker.register('./sw.js')\n        .then(() => {\n            console.log(\"SW Registered\");\n            // Give SW a moment to activate and claim\n            setTimeout(() => {\n                const iframe = document.getElementById('content') as HTMLIFrameElement;\n                iframe.src = \"/p2p/index.html\";\n            }, 1000);\n        })\n        .catch(err => console.error(err));\n};\n\npc.onicecandidate = (event) => {\n    if (event.candidate) {\n        ws.send(JSON.stringify({ type: 'candidate', candidate: event.candidate }));\n    }\n};\n\nws.onopen = async () => {\n    console.log('Connected to signaling server');\n    // Create Offer\n    const offer = await pc.createOffer();\n    await pc.setLocalDescription(offer);\n    ws.send(JSON.stringify({ type: 'offer', offer }));\n};\n\nws.onmessage = async (event) => {\n    const msg = JSON.parse(event.data);\n    if (msg.type === 'answer') {\n        await pc.setRemoteDescription(msg.answer);\n    } else if (msg.type === 'candidate') {\n        await pc.addIceCandidate(msg.candidate);\n    }\n};\n"],
  "mappings": "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",
  "names": ["WebRtcHttpBridge", "dc"]
}
